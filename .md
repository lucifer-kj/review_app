// Enhanced SPA routing support for magic links and client-side routing
(function() {
  // Store the original URL before any processing
  const originalUrl = window.location.href;
  console.log('Original URL:', originalUrl);
  
  // Enhanced magic link detection and handling
  function handleMagicLink() {
    const url = new URL(window.location.href);
    const hash = url.hash;
    const pathname = url.pathname;
    
    // Check for Supabase magic link patterns
    const isSupabaseMagicLink = hash && (
      hash.includes('access_token=') || 
      hash.includes('refresh_token=') ||
      hash.includes('type=recovery') ||
      hash.includes('type=invite') ||
      hash.includes('type=signup')
    );
    
    // Check for magic link routes
    const isMagicLinkRoute = [
      '/accept-invitation',
      '/test-accept-invitation',
      '/auth/callback',
      '/reset-password',
      '/verify-email'
    ].some(route => pathname.startsWith(route));
    
    if (isSupabaseMagicLink || isMagicLinkRoute) {
      console.log('Magic link detected:', { pathname, hash: hash.substring(0, 50) + '...' });
      
      // Store magic link data for React app to process
      sessionStorage.setItem('magic_link_data', JSON.stringify({
        pathname,
        hash,
        timestamp: Date.now(),
        processed: false
      }));
      
      // For hash-based auth, convert to query params for better React Router handling
      if (isSupabaseMagicLink && hash) {
        try {
          const hashParams = new URLSearchParams(hash.substring(1));
          const newUrl = new URL(window.location.href);
          
          // Move critical auth params to search params
          const authParams = ['access_token', 'refresh_token', 'expires_in', 'token_type', 'type'];
          authParams.forEach(param => {
            if (hashParams.has(param)) {
              newUrl.searchParams.set(param, hashParams.get(param));
            }
          });
          
          // Clear the hash to avoid conflicts
          newUrl.hash = '';
          
          // Update URL without reload
          window.history.replaceState(null, null, newUrl.toString());
          console.log('Converted hash params to search params for magic link');
        } catch (error) {
          console.warn('Error processing magic link hash:', error);
        }
      }
      
      return true;
    }
    
    return false;
  }
  
  // Handle hash fragments for magic links
  const isMagicLink = handleMagicLink();
  
  // Service Worker registration
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function() {
      navigator.serviceWorker.register('/sw.js')
        .then(function(registration) {
          console.log('SW registered: ', registration);
        })
        .catch(function(registrationError) {
          console.log('SW registration failed: ', registrationError);
        });
    });
  }
  
  // Enhanced SPA routing fallback with magic link protection
  window.addEventListener('DOMContentLoaded', function() {
    console.log('SPA fallback loaded, current path:', window.location.pathname);
    
    // Check if we're on a client route and the page might be blank
    const isClientRoute = !window.location.pathname.includes('.') && 
                         !window.location.pathname.startsWith('/api') &&
                         window.location.pathname !== '/';
    
    if (isClientRoute && !isMagicLink) {
      console.log('Client route detected, ensuring React Router handles it');
      
      // Use longer delay for slower connections, but check multiple times
      let checkCount = 0;
      const maxChecks = 10;
      
      const checkInterval = setInterval(function() {
        checkCount++;
        const root = document.getElementById('root');
        
        if (root && root.innerHTML.trim() !== '') {
          // React has loaded successfully
          clearInterval(checkInterval);
          console.log('React app loaded successfully');
          return;
        }
        
        if (checkCount >= maxChecks) {
          clearInterval(checkInterval);
          console.log('Max checks reached, reloading page');
          
          // Only reload if it's not a magic link to avoid losing auth state
          const magicLinkData = sessionStorage.getItem('magic_link_data');
          if (!magicLinkData) {
            window.location.reload();
          } else {
            console.warn('Avoiding reload due to magic link presence');
          }
        }
      }, 200);
    }
  });
  
  // Handle browser back/forward navigation
  window.addEventListener('popstate', function(event) {
    console.log('Popstate event:', event.state);
    
    // Re-check for magic links on navigation
    handleMagicLink();
  });
  
  // Provide utility function for React app to access magic link data
  window.getMagicLinkData = function() {
    const data = sessionStorage.getItem('magic_link_data');
    if (data) {
      try {
        return JSON.parse(data);
      } catch (error) {
        console.error('Error parsing magic link data:', error);
        sessionStorage.removeItem('magic_link_data');
        return null;
      }
    }
    return null;
  };
  
  // Allow React app to mark magic link as processed
  window.markMagicLinkProcessed = function() {
    const data = sessionStorage.getItem('magic_link_data');
    if (data) {
      try {
        const parsed = JSON.parse(data);
        parsed.processed = true;
        sessionStorage.setItem('magic_link_data', JSON.stringify(parsed));
        console.log('Magic link marked as processed');
      } catch (error) {
        console.error('Error updating magic link data:', error);
      }
    }
  };
  
  // Clean up old magic link data (older than 10 minutes)
  const cleanupOldMagicLinkData = function() {
    const data = sessionStorage.getItem('magic_link_data');
    if (data) {
      try {
        const parsed = JSON.parse(data);
        const tenMinutesAgo = Date.now() - (10 * 60 * 1000);
        
        if (parsed.timestamp < tenMinutesAgo) {
          sessionStorage.removeItem('magic_link_data');
          console.log('Cleaned up old magic link data');
        }
      } catch (error) {
        console.error('Error cleaning up magic link data:', error);
        sessionStorage.removeItem('magic_link_data');
      }
    }
  };
  
  // Run cleanup on load
  cleanupOldMagicLinkData();
})();

---

{
  "rewrites": [
    {
      "source": "/(.*)",
      "destination": "/index.html"
    }
  ],
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        {
          "key": "Content-Security-Policy",
          "value": "default-src 'self'; script-src 'self' 'unsafe-inline' https://*.supabase.co https://*.supabase.io https://cdn.jsdelivr.net https://unpkg.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://cdn.jsdelivr.net; font-src 'self' https://fonts.gstatic.com https://cdn.jsdelivr.net; img-src 'self' data: blob: https://*.supabase.co https://*.supabase.io; connect-src 'self' https://*.supabase.co https://*.supabase.io https://api.resend.com https://api.sendgrid.com; frame-src 'none'; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none'; upgrade-insecure-requests;"
        },
        {
          "key": "X-Frame-Options",
          "value": "DENY"
        },
        {
          "key": "X-Content-Type-Options",
          "value": "nosniff"
        },
        {
          "key": "Referrer-Policy",
          "value": "strict-origin-when-cross-origin"
        },
        {
          "key": "Permissions-Policy",
          "value": "camera=(), microphone=(), geolocation=(), payment=(), usb=(), magnetometer=(), gyroscope=(), accelerometer=(), ambient-light-sensor=(), autoplay=(), battery=(), bluetooth=(), display-capture=(), fullscreen=(self), picture-in-picture=(), screen-wake-lock=(), web-share=(), xr-spatial-tracking=()"
        },
        {
          "key": "Strict-Transport-Security",
          "value": "max-age=31536000; includeSubDomains; preload"
        },
        {
          "key": "X-XSS-Protection",
          "value": "1; mode=block"
        },
        {
          "key": "Cross-Origin-Embedder-Policy",
          "value": "require-corp"
        },
        {
          "key": "Cross-Origin-Opener-Policy",
          "value": "same-origin"
        },
        {
          "key": "Cross-Origin-Resource-Policy",
          "value": "same-origin"
        }
      ]
    },
    {
      "source": "/index.html",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=0, must-revalidate"
        }
      ]
    },
    {
      "source": "/accept-invitation",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "no-cache, no-store, must-revalidate"
        },
        {
          "key": "Pragma",
          "value": "no-cache"
        },
        {
          "key": "Expires",
          "value": "0"
        }
      ]
    },
    {
      "source": "/test-accept-invitation",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "no-cache, no-store, must-revalidate"
        },
        {
          "key": "Pragma",
          "value": "no-cache"
        },
        {
          "key": "Expires",
          "value": "0"
        }
      ]
    },
    {
      "source": "/auth/(.*)",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "no-cache, no-store, must-revalidate"
        }
      ]
    }
  ],
  "redirects": [
    {
      "source": "/api/:path*",
      "destination": "https://api.crux.app/:path*",
      "permanent": false
    }
  ],
  "trailingSlash": false,
  "cleanUrls": true
}

---

// In your React component or routing logic
useEffect(() => {
  const magicLinkData = window.getMagicLinkData?.();
  
  if (magicLinkData && !magicLinkData.processed) {
    console.log('Processing magic link:', magicLinkData);
    
    // Handle the magic link authentication
    // e.g., extract tokens, call Supabase auth, etc.
    
    // Mark as processed when done
    window.markMagicLinkProcessed?.();
  }
}, []);